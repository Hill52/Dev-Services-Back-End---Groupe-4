version: '3.9'

services:
  orders:
    image: node:alpine
    # command: npm start #production
    command: npm run watch
    #command: npm run watch #pour le dévellopement seulement (fonctionne uniquement si Nodemon est installé)
    #command: npm test
    env_file:
      #définit l'emplacement du fichier de variables d'environnement
      - .env
    working_dir: /usr/src/app
    # ports:
    #   - 3333:3000 #associe le port local 3333 au port 3000 du container
    volumes:
      - ./orders:/usr/src/app #synchronise le répertoire local ./api avec le répertoire du container /usr/src/app
    networks:
      - some_network
    links:
      - mariadb #facilite l'accès à la base de données via le network
    depends_on:
      #permet d'organiser le démarrage des services
      mariadb:
        condition: service_healthy #vérifie que le serveur de base de données est prêt et fonctionnel

  auth:
    image: node:alpine
    # command: npm start #production
    command: npm run watch
    #command: npm run watch #pour le dévellopement seulement (fonctionne uniquement si Nodemon est installé)
    #command: npm test
    env_file:
      #définit l'emplacement du fichier de variables d'environnement
      - dbauth.env
    working_dir: /usr/src/app
    # ports:
    #   - 3000:3000 #associe le port local 3333 au port 3000 du container
    volumes:
      - ./auth:/usr/src/app #synchronise le répertoire local ./api avec le répertoire du container /usr/src/app
    networks:
      - some_network
    links:
      - mariadb #facilite l'accès à la base de données via le network
    depends_on:
      #permet d'organiser le démarrage des services
      mariadb:
        condition: service_healthy #vérifie que le serveur de base de données est prêt et fonctionnel

  gateway:
    image: node:alpine
    # command: npm start #production
    command: npm run watch
    #command: npm run watch #pour le dévellopement seulement (fonctionne uniquement si Nodemon est installé)
    #command: npm test
    env_file:
      #définit l'emplacement du fichier de variables d'environnement
      - gateway.env
    working_dir: /usr/src/app
    ports:
      - 3000:3000 #associe le port local 3333 au port 3000 du container
    volumes:
      - ./gateway:/usr/src/app #synchronise le répertoire local ./api avec le répertoire du container /usr/src/app
    networks:
      - some_network
    links:
      - auth
      - orders
      - directus

  mariadb:
    image: mariadb
    env_file:
      #définit l'emplacement du fichier de variables d'environnement
      - .env
    volumes:
      - ./db/data:/var/lib/mysql #synchronise le répertoire local ./db/data avec le répertoire du container /var/lib/mysql
      - ./db/sql:/docker-entrypoint-initdb.d #initialise la base de données à l'aide des fichiers SQL présents dans le volume local ./db/sql
    ports:
      - 3306:3306 #associe le port local 3306 au port 3306 du container
    networks:
      - some_network
    healthcheck:
      #vérifie le fonctionnement du service
      test:
        [
          "CMD",
          "mysqladmin",
          "ping",
          "-h",
          "localhost",
          "-uroot",
          "-p${MARIADB_ROOT_PASSWORD}"
        ]
      interval: 5s
      timeout: 5s
      retries: 20

  dbauth:
    image: mariadb
    env_file:
      #définit l'emplacement du fichier de variables d'environnement
      - dbauth.env
    volumes:
      - ./db/auth_data:/var/lib/mysql #synchronise le répertoire local ./db/data avec le répertoire du container /var/lib/mysql
      - ./db/auth_sql:/docker-entrypoint-initdb.d #initialise la base de données à l'aide des fichiers SQL présents dans le volume local ./db/sql
    ports:
      - 3307:3306 #associe le port local 3306 au port 3306 du container
    networks:
      - some_network
    healthcheck:
      #vérifie le fonctionnement du service
      test:
        [
          "CMD",
          "mysqladmin",
          "ping",
          "-h",
          "localhost",
          "-uroot",
          "-p${MARIADB_ROOT_PASSWORD}"
        ]
      interval: 5s
      timeout: 5s
      retries: 20

  adminer:
    image: adminer
    env_file:
      #définit l'emplacement du fichier de variables d'environnement
      - .env
    ports:
      - 8181:8080 #associe le port local 8181 au port 8080 du container
    networks:
      - some_network

  database:
    container_name: database
    image: postgis/postgis:13-master
    # Required when running on platform other than amd64, like Apple M1/M2:
    # platform: linux/amd64
    volumes:
      - ./data/database:/var/lib/postgresql/data
    networks:
      - some_network
    environment:
      POSTGRES_USER: 'directus'
      POSTGRES_PASSWORD: 'directus'
      POSTGRES_DB: 'directus'

  directus:
    container_name: directus
    image: directus/directus:latest
    # ports:
      # - 8055:8055
    volumes:
        # By default, uploads are stored in /directus/uploads
        # Always make sure your volumes matches the storage root when using
        # local driver
      - ./uploads:/directus/uploads
        # Make sure to also mount the volume when using SQLite
        # - ./database:/directus/database
        # If you want to load extensions from the host
        # - ./extensions:/directus/extensions
    networks:
      - some_network
    depends_on:
      - database
    environment:
      KEY: '255d861b-5ea1-5996-9aa3-922530ec40b1'
      SECRET: '6116487b-cda1-52c2-b5b5-c8022c45e263'

      DB_CLIENT: 'pg'
      DB_HOST: 'database'
      DB_PORT: '5432'
      DB_DATABASE: 'directus'
      DB_USER: 'directus'
      DB_PASSWORD: 'directus'


      ADMIN_EMAIL: 'admin@example.com'
      ADMIN_PASSWORD: 'd1r3ctu5'

        # Make sure to set this in production
        # (see https://docs.directus.io/self-hosted/config-options#general)
        # PUBLIC_URL: 'https://directus.example.com'


networks:
  #définit un réseau
  some_network:
    driver: bridge